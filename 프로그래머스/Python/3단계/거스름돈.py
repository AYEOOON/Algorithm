"""
처음엔 브루트 포스 방법으로 풀려고 했지만 시간초과 발생

다음으로 DP 시도

💡 핵심 아이디어:
- 작은 금액부터 시작하여 각 동전을 이용해 만들 수 있는 경우의 수를 누적해서 저장하면 -> 효율적 탐색 가능

🔹 1. DP 배열 정의
- dp[i]를 금액 i를 만드는 경우의 수라고 정의
- dp[0] = 1 로 초기화 → 아무 동전도 사용하지 않는 경우(0원 만들기)는 1가지.

🔹 2. 동전 하나씩 고려하면서 경우의 수를 누적
- money 리스트에 있는 각 동전을 하나씩 확인
- 해당 동전을 사용해서 만들 수 있는 모든 금액을 갱신
"""

def solution(n, money):
    dp = [0] * (n + 1)
    dp[0] = 1  # 0원을 만드는 경우는 아무 동전도 사용하지 않는 1가지 경우

    for coin in money:  # 각 동전에 대해
        for i in range(coin, n + 1):  # 해당 동전으로 만들 수 있는 금액부터 계산
            dp[i] += dp[i - coin]  # 현재 금액에서 (현재 금액 - 동전 금액)의 경우의 수를 추가

    return dp[n] % 1000000007  # n원을 만드는 경우의 수 반환
