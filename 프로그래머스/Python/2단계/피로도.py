"""
XX게임에는 피로도 시스템(0 이상의 정수로 표현합니다)이 있으며, 일정 피로도를 사용해서 던전을 탐험할 수 있습니다. 
이때, 각 던전마다 탐험을 시작하기 위해 필요한 "최소 필요 피로도"와 던전 탐험을 마쳤을 때 소모되는 "소모 피로도"가 있습니다.
"최소 필요 피로도"는 해당 던전을 탐험하기 위해 가지고 있어야 하는 최소한의 피로도를 나타내며, "소모 피로도"는 던전을 탐험한 후 소모되는 피로도를 나타냅니다. 
이 게임에는 하루에 한 번씩 탐험할 수 있는 던전이 여러개 있는데, 
한 유저가 오늘 이 던전들을 최대한 많이 탐험하려 합니다. 
유저의 현재 피로도 k와 각 던전별 "최소 필요 피로도", "소모 피로도"가 담긴 2차원 배열 dungeons 가 매개변수로 주어질 때, 
유저가 탐험할수 있는 최대 던전 수를 return 하도록 solution 함수를 완성해주세요.
"""

# 파이썬 라이브러리 중 순열을 이용하여 각 탐험할 수 있는 경우를 구한다.
# 조합한 경우의 수를 모두 탐색하여 큰 수를 저장한다.

# 내 풀이
from itertools import permutations

def solution(k, dungeons):
    arr = list(permutations(dungeons, len(dungeons)))
    ad = 0
    for i in arr:
        re = k
        cnt = 0
        for j in i:
            if re >= j[0]:
                re -= j[1]
                cnt += 1
        ad = max(ad, cnt)

    return ad
    

# 다른사람 풀이
# (m, u)는 d의 값, 즉 m = 최소피로도, u = 소모피로도
# 리스트 컴프리헨션의 각 요소는 k>m 때 생성
# solution(총 피로도, 던전의 배열) 함수에 현재 피로도-소모피로도를 다시 총피로도라는 매개변수로 넣어주고
# 던전의 배열이라는 매개변수에는 던전의 i번째 던전을 제거한 모든 던전의 배열을 다시 집어 넣는다.
# 그리고 1을 더한 것. solution이라는 함수 자체가 저 값과 0 중에 큰 것을 리턴하는데, 
# 저 값이라는 것에 solution이 들어 있으니 아마도 재귀함수 같다. ﻿
solution = lambda k, d: max([solution(k - u, d[:i] + d[i+1:]) + 1 for i, (m, u) in enumerate(d) if k >= m] or [0]
