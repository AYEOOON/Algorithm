# 다시 풀어봐야하는 문제

# 목재를 충분히 모은 lvalue는 집을 짓기로 하였다. 
# 하지만 고르지 않은 땅에는 집을 지을 수 없기 때문에 땅의 높이를 모두 동일하게 만드는 ‘땅 고르기’ 작업을 해야 한다.
# lvalue는 세로 N, 가로 M 크기의 집터를 골랐다. 
# 집터 맨 왼쪽 위의 좌표는 (0, 0)이다. 우리의 목적은 이 집터 내의 땅의 높이를 일정하게 바꾸는 것이다. 
# 우리는 다음과 같은 두 종류의 작업을 할 수 있다.

# 1. 좌표 (i, j)의 가장 위에 있는 블록을 제거하여 인벤토리에 넣는다.
# 2. 인벤토리에서 블록 하나를 꺼내어 좌표 (i, j)의 가장 위에 있는 블록 위에 놓는다.

# 1번 작업은 2초가 걸리며, 2번 작업은 1초가 걸린다. 밤에는 무서운 몬스터들이 나오기 때문에 최대한 빨리 땅 고르기 작업을 마쳐야 한다.
# ‘땅 고르기’ 작업에 걸리는 최소 시간과 그 경우 땅의 높이를 출력하시오.
# 단, 집터 아래에 동굴 등 빈 공간은 존재하지 않으며, 집터 바깥에서 블록을 가져올 수 없다.
# 또한, 작업을 시작할 때 인벤토리에는 B개의 블록이 들어 있다. 땅의 높이는 256블록을 초과할 수 없으며, 음수가 될 수 없다.

# 문제의 핵심은 인벤토리로 들어가는 블록의 갯수와 초기 인벤토리를 합한 것이 인벤토리에서 나가는 블록의 갯수보다 크거나 같다면, 그 목표높이로 땅을 고를 수 있다는 것이다. 

# 풀이
from math import inf
import sys
input = sys.stdin.readline

N, M, B = map(int,input().split())

grd = [list(map(int,input().split())) for _ in range(N)]

tall = 0
ans = inf  # 시간초과 방지를 위해 충분히 큰수로 둠

for i in range(257): # 땅의 높이의 최대는 256이므로 0~256까지만 탐색
  remove = 0  # 1번작업
  build = 0   # 2번작업
  for n in range(N):  # 가로
    for m in range(M):# 세로
      if grd[n][m] < i:  # 만약 블럭이 현재 높이보다 작다면
        build += (i - grd[n][m])  # build만큼 인벤토리에서 꺼내서 채워야함

      else: # 블럭이 현재 높이보다 크다면
        remove += (grd[n][m] - i)  # remove만큼 블록을 제거한 후 인벤토리에 들어감

  inventory = remove + B  # 인벤토리에 있는 블록수 = 제거한 블록의 수 + 현재 인벤토리에 있는 블록 수 

  if inventory < build: # 인벤토리에 있는 블록수가 꺼내야하는 블록 수 보다 적으면 패스
    continue

  time = 2*remove + build # 블록제거는 2초 쌓는건 1초

  if time <= ans: # 높이는 0 ~ 256 까지 오름차순으로 탐색하기 때문에 걸린 시간이 같아도 더 높은 높이가 출력 된다
    ans = time
    tall = i

print(ans, tall)
