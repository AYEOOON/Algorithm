"""
한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다.
각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 
단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다.
회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.
"""
"""
그리디는 당장의 상황을 기준으로 확장시키는 방향으로 풀면 쉽게 해결이 가능한 경우가 많다.
내가 회의실을 사용하고 있다고 가정했을 때, 내 회의가 끝난 후에 회의실에서 가장 많은 회의가 열리기 위해서는 종료 시간이 빨라야 한다.
여기서 한가지 더 고려해야 할 점은 바로 종료시간이 같은 경우이다.

예를 들어, (10, 10) 의 회의와 (9,10)회의가 있을 때, 둘의 종료 시간은 같지만, (9,10)를 먼저 선택하면, (10,10)의 회의를 선택할 기회가 주어진다. 하지만, (10, 10)의 회의가 먼저 선택되면, 종료시간이 10을 넘어갔기 때문에 9시작은 고려되지 않는다.

따라서 시작시간으로 먼저 정렬을 해준 후에, 종료 시간을 기준으로 정렬을 해준다.
이렇게 정렬을 한 후에, 종료 시간을 꼬리잡기 식으로 이어나가면 최대 개수를 구할 수 있게 된다.
"""

# 내 풀이
import sys
input = sys.stdin.readline

N = int(input())

time = []

for i in range(N):
  time.append(list(map(int,input().split())))

time.sort(key = lambda x : x[0]) # 시작시간 기준으로 정렬
time.sort(key = lambda x : x[1]) # 종료시간 기준으로 정렬

cnt = 1
end = time[0][1]
for i in range(1, N):
  if time[i][0] >= end:  # 회의가 덜 끝났을 때
    cnt += 1
    end = time[i][1]

print(cnt)
